Network Working Group                                      G. Villemonte
Intended status: Informational                              C. Chellier
                                                            M. Coutaye
                                                            L. Hoareau
Expires: June 2027                                          December 2025

                   R-Type Mirror UDP Gameplay Protocol
                            r-type-mirror

Abstract

   This document describes the UDP-based gameplay protocol used in the
   r-type-mirror project, a multiplayer shoot'em up game.  The protocol
   handles real-time transmission of player inputs from clients to the
   server and entity position updates from the server to clients.  It is
   designed to be lightweight and low-latency, relying on UDP for
   performance while accepting potential packet loss.

1.  Introduction

   The r-type-mirror UDP Gameplay Protocol is a simple, connectionless
   protocol used for the real-time exchange of game state in a
   multiplayer horizontal shoot'em up game inspired by R-Type.  It
   operates over UDP and is complemented by a separate TCP channel for
   connection establishment, keep-alive (ping/pong), and client
   discovery.

   The protocol has two independent data flows:

   o  Client to Server: frequent transmission of player input states.
   o  Server to Client: periodic broadcast of entity position snapshots.

   No handshake, sequencing, or reliability mechanisms are defined at
   the UDP level; reliability for connection management is handled via
   the parallel TCP channel.

   Default UDP port: 53000 (configurable).

2.  Data Structures

   All multi-byte values are transmitted in network byte order
   (big-endian).  Structures are packed with no padding beyond what is
   explicitly defined.

2.1.  InputState (Client -> Server)

   The InputState structure represents the current control inputs of a
   player.  It is exactly 3 bytes in size.

      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     |U|D|L|R|S|     |
     +-+-+-+-+-+-+-+-+
     |      Tick     |
     |    (uint16)   |
     +-+-+-+-+-+-+-+-+

     U (bit 0): Up    (1 = pressed)
     D (bit 1): Down  (1 = pressed)
     L (bit 2): Left  (1 = pressed)
     R (bit 3): Right (1 = pressed)
     S (bit 4): Shoot (1 = pressed)
     Bits 5-7: Reserved (must be 0)
     Tick:     Client-side frame counter (for input ordering) or Magic Number.

   Reserved Values for InputState Tick:

   o  0xFFFA (65530): "Client Quit"
      - Indicates that the client is disconnecting voluntarily.
      - The server should remove the player entity and close the session.

   Each InputState is sent in its own UDP datagram (3 bytes payload).

2.2.  EntityUpdate (Server -> Client)

   The EntityUpdate structure conveys the minimal state of a single
   game entity.  It is exactly 22 bytes in size.

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         entityId (uint32)                     |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                           tick (uint16)                       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                            x (float)                          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                            y (float)                          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       health_current (int32)                  |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         health_max (int32)                    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     entityId:       Unique identifier for the entity.
     tick:           Server frame counter or Magic Number (see 2.3).
     x, y:           Floating-point position coordinates.
     health_current: Current health points of the entity.
     health_max:     Maximum health points of the entity.

   A single UDP datagram from server to client may contain zero or more
   concatenated EntityUpdate structures.  The total payload length MUST
   be an exact multiple of 22 bytes.  The number of updates is derived
   as payload_length / 22.

2.3.  Magic Numbers (Tick Field)

   The `tick` field in the EntityUpdate structure is normally used to
   synchronize game state. However, specific values are reserved as
   "Magic Numbers" to convey special events or status information to
   the client without adding extra packet overhead.

   Reserved Values:

   o  0xFFFF (65535): "This Is You"
      - Indicates that the entity described in this update belongs to
        the receiving client (i.e., it is their player ship).
      - Used by the client to identify its own character for camera
        tracking, UI display, or local prediction.

   o  0xFFFE (65534): "Entity Died"
      - Indicates that the entity has been destroyed (health <= 0).
      - The client should remove this entity from its local state.
      - This is a generic death notification (e.g., killed by enemy,
        environment, or another player).

   o  0xFFFD (65533): "You Killed It"
      - Indicates that the entity has been destroyed AND the receiving
        client was the one who dealt the final blow.
      - The client should remove the entity and may trigger specific
        feedback (score increase, "kill" sound effect, visual flair).

   o  0xFFFC (65532): "Enemy Shot"
      - Indicates that a non-player entity (enemy) has fired a projectile.
      - Used to trigger visual/audio effects on the client.

   o  0xFFFB (65531): "Player Shot"
      - Indicates that a player entity has fired a projectile.
      - Used to trigger visual/audio effects on the client.

   o  Any other value: Standard Server Tick
      - Represents the frame number at which this state was captured.

3.  Protocol Operation

3.1.  Client to Server Flow (Player Inputs)

   Clients send InputState datagrams as frequently as possible
   (typically 60-120 Hz or on every input change).  Each datagram is
   sent to the server's UDP port with a 3-byte payload.

   The server identifies clients by source IP address and source port.
   The first received InputState from an unknown endpoint automatically
   registers the client (up to MAX_CLIENTS = 4).  Subsequent inputs from
   the same endpoint are associated with the registered player.

   No acknowledgment is sent.

3.2.  Server to Client Flow (Entity Snapshots)

   Periodically (typically 30-60 Hz), the server constructs a snapshot
   containing the current position of all relevant entities.

   For each connected client, the server queues a datagram containing
   the concatenated EntityUpdate structures and sends it to the
   client's registered IP and port.

   All clients receive identical snapshots (full state, no delta
   encoding in the current implementation).

3.3.  Client Management and Discovery

   Initial client discovery, player ID assignment, and connection
   keep-alive are handled over a separate TCP channel (default port
   53001) using a simple ping/pong mechanism.

   The UDP gameplay protocol begins only after successful TCP
   connection.

4.  Packet Size Considerations

   Datagrams should respect typical path MTU (approximately 1400 bytes
   after headers).  With 22-byte EntityUpdate structures, a single
   datagram can carry up to approximately 63 entities.

5.  Security Considerations

   This protocol provides no authentication, encryption, or integrity
   checks.  Implementations operate under the assumption of a trusted
   local or controlled network.  Spoofing of source IP/port is possible
   and could lead to unauthorized input injection or denial of service.

   Production deployments should consider additional measures such as
   VPN tunneling or application-level authentication.

6.  IANA Considerations

   This document has no IANA actions.

Authors' Addresses

   Gabriel Villemonte
   Epitech Student
   Email: gabriel.villemonte@epitech.eu

   Clement Chellier
   Epitech Student
   Email: clement.chellier@epitech.eu

   Mathis Coutaye
   Epitech Student
   Email: mathis.coutaye@epitech.eu

   Lucas Hoareau
   Epitech Student
   Email: lucas.hoareau@epitech.eu
